## 대면 스터디

- 날짜 : 11월 24일 오전 10시

## 문제 1 : 개인정보 수집 유효기간

### 1. **문제 설명**

> 주어진 입력과 요구되는 출력에 대해 간략히 설명해주세요.

- 입력 :

  - today는 "YYYY.MM.DD" 형태로 오늘 날짜를 나타냅니다.
  - tems는 약관의 유효기간을 담은 1차원 문자열 배열입니다
    - terms의 원소는 "약관 종류 유효기간" 형태의 약관 종류와 유효기간을 공백 하나로 구분한 문자열입니다.
  - privacies는 수집된 개인정보의 정보를 담은 1차원 문자열 배열입니다

    - privacies의 원소는 "날짜 약관 종류" 형태의 날짜와 약관 종류를 공백 하나로 구분한 문자열입니다.

  - today와 privacies에 등장하는 날짜의 YYYY는 연도, MM은 월, DD는 일을 나타내며 점(.) 하나로 구분되어 있습니다.
    - 2000 ≤ YYYY ≤ 2022
    - 1 ≤ MM ≤ 12
    - MM이 한 자릿수인 경우 앞에 0이 붙습니다.
    - 1 ≤ DD ≤ 28
    - DD가 한 자릿수인 경우 앞에 0이 붙습니다.

- 출력 : 파기해야 할 개인정보의 번호(=인덱스+1)를 오름차순으로 1차원 정수 배열에 담아서 출력합니다.

### 2. **문제의 엣지 케이스**

> 해당 문제가 가질 수 있는 극단적인 케이스에 대해 적어주세요.

- 수개월이 지난 뒤의 날짜 결과는 개월 단위만 더해주는 것이 아니라,
  일 단위에서도 -1을 해줘야 하므로 주의를 요구합니다.
  그렇기 때문에 약관의 만료일이 정확히 오늘과 동일한 날짜의 경우가 아닐까 싶습니다.

  ```tsx
  today > 2023.04.30

  2021.05.01 , 유효기간 24 >> 2023.04.30
  ```

### 3. **사용한 데이터 구조와 알고리즘**

> 문제를 풀기 위해 사용한 주요한 데이터 구조 및 알고리즘에 대해 적어주세요.

- 문자열처리, 구현

### 4. **의사 코드**

> 구현한 코드를 단계별로 설명해 주세요.

- 인자로 넘겨받은 yyyy.mm.dd 형식의 날짜들을 가장 작은 단위(dd)로 수치화를 진행하는 convertDate 함수를 생성합니다

  ```tsx
  2023.11.24
  >> 2023*(28*12) + 11*28 + 24

  // 년 => 한달의 dd * 12개월
  // 월 => 한달의 dd
  // 일 => dd
  ```

- convertDate를 기반으로 아래의 날짜들을 계산합니다

  - 오늘 날짜
  - 인자로 넘겨받은 날짜 + 약관에 맞는 개월 수

- 위의 계산 결과들을 대소비교하며 약관 만료를 판별합니다

### 5. **시간 복잡도, 공간 복잡도 측정**

> 구현한 코드의 시간 복잡도와 공간 복잡도를 그 이유와 함께 적어주세요.

1.

### 6. **최적화**

> 구현한 코드에서 최적화 할 수 있는 부분이 있을까요? 있다면 어떻게 수정되어야 할까요?

- 사실 단순 문자열 처리와 시간을 최소단위로 변환하는 부분이 관건인 문제였고 주어진 인자의 길이가 별로 길지 않았기에 시간복잡도 측면에서 큰 개선점은 찾지 못했습니다
- 그렇지만 맨 마지막에 result를 `오름차순으로 정렬해서` 출력하는 부분이 있는데,
  현재 로직에서는 privacies를 for문으로 0번 인덱스부터 이미 오름차순으로 순회하며 result에 값을 넣어주고 있습니다
  그렇기 때문에 굳이 마지막에 정렬을 할 필요는 없는 것 같습니다

### 7. **배운 점 또는 추가로 생각해볼 점**

> 인사이트에 대해 간략히 적어주세요.

- 사실 실제로 이 문제를 작년 코테를 보면서 처음 접했을 때,
  Date객체를 쓰려다가 실패해서 일일이 조건부 처리로 진행을 하며 시간을 너무 오래 썼던 경험이 있습니다. 이를 통해 ‘문제에서 그대로 하라는 대로’ 구현을 하는 것 보다
  ‘문제에서 요구하는’ 부분에 대해 보다 넓게 봐야한다는 것을 깨달았습니다

<br>
<br>

## 문제 2 : 이모티콘 할인행사

### 1. **문제 설명**

> 주어진 입력과 요구되는 출력에 대해 간략히 설명해주세요.

- 입력 :
  - 카카오톡 사용자 n명의 구매 기준을 담은 2차원 정수 배열 users
    - users의 원소는 [비율, 가격]의 형태입니다.
    - users[i]는 i+1번 고객의 구매 기준을 의미합니다.
  - 이모티콘 m개의 정가를 담은 1차원 정수 배열 emoticons
    - emoticons[i]는 i+1번 이모티콘의 정가를 의미합니다.
    - 100 ≤ emoticons의 원소 ≤ 1,000,000
    - emoticons의 원소는 100의 배수입니다.
- 출력 :
  - 행사 목적을 최대한으로 달성했을 때의 이모티콘 플러스 서비스 가입 수와 이모티콘 매출액을 1차원 정수 배열에 담아 return

### 2. **문제의 엣지 케이스**

> 해당 문제가 가질 수 있는 극단적인 케이스에 대해 적어주세요.

- 완전탐색으로 푸는 만큼, 딱히 생각나는 엣지 케이스가 떠오르질 않습니다…

### 3. **사용한 데이터 구조와 알고리즘**

> 문제를 풀기 위해 사용한 주요한 데이터 구조 및 알고리즘에 대해 적어주세요.

- 백트래킹을 통한 `중복이 허용된` 순열 구현

### 4. **의사 코드**

> 구현한 코드를 단계별로 설명해 주세요.

1. 백트래킹을 이용해서 10 20 30 40 으로 만들 수 있는
   `중복이 존재하는 순열` 을 구현합니다
2. 각 순열 경우에 따라 할인율을 적용하고 이에 맞는 결과를 계산합니다

   1. emoticons 배열의 값을 순회하며 할인된 가격을 적용한 배열

      discountedPriceArr 를 생성합니다

   2. users를 순회하며 할인율에 따른 구매 여부와

      동시에 이모티콘 플러스 구독 여부를 계산

      > discountArr와 discountedPriceArr는 할인율과, 할인율이 적용된 가격을 의미하므로 같은 인덱스를 공유합니다

      ```tsx
      discountArr[3] 만큼 할인이 적용된 가격 === discountedPriceArr[3]
      ```

   3. 구독 여부에 따른 결과를 result배열에 push합니다
      ( [가입자 수,매출액] )

3. 최종적으로 result배열에서 가입자 수를 내림차순으로,

   가입자 수가 동일하다면 매출액을 내림차순으로 정렬합니다

### 5. **시간 복잡도, 공간 복잡도 측정**

> 구현한 코드의 시간 복잡도와 공간 복잡도를 그 이유와 함께 적어주세요.

1.

### 6. **최적화**

> 구현한 코드에서 최적화 할 수 있는 부분이 있을까요? 있다면 어떻게 수정되어야 할까요?

- 할인율에 따른 각 사람에 대한 계산 결과를 구하는 과정에서
  주어진 가격 이상을 구매할 시 구독을 하게 되는 부분을 처리하는데, 이 때 바로 break를 해버려서 조금의 최적화를 더 할 수 있을 것 같습니다
  ```tsx
  if (buyListPrice >= price) {
  	isEnroll = true;
  	break; // 추가
  }
  ```
- 마지막에 2차원 배열인 result 를 한번에 sort하는게 아니라
  각 할인율에 따른 결과를 도출해 낼 때마다 최댓값을 갱신하는 방법이 좀 더 효율적일 것 같기도 합니다

### 7. **배운 점 또는 추가로 생각해볼 점**

> 인사이트에 대해 간략히 적어주세요.

1. 문제가 요구하는 조건에서 규칙을 찾기 힘들거나, 혹은 너무 까다로운 경우 완전탐색을 가장 먼저 의심해봐야 할 것 같습니다

   물론 난이도가 더 높은 경우 이분탐색, 그리디, 투포인터 같은 다양한 방법이 있겠지만 문제에서 주어진 인자의 크기가 별로 크지 않은 경우에는 완전탐색으로 푸는 방법이 맞는 것 같습니다

2. 재귀를 구현하면서 가장 주의할 부분이 바로 call by reference에 의한 원본 변경 여부라고 생각합니다

   이 부분은 원래 깊은 복사로 해결했는데, 이번에는 return하기 직전에 해당 경우의 수를 가지고 할인율에 따른 계산을 바로 진행했습니다
