## 대면 스터디

- 푼 사람 : @Seo0H
- 날짜 : 11월 24일 오전 10시
- 푼 문제
  - [x] [개인정보 수집 유효기간](개인정보%20수집%20유효기간.js)
  - [x] [이모티콘 할인행사](이모티콘%20할인행사.js)
  - [x] [택배 배달과 수거하기](./택배%20배달과%20수거하기.js)

---

## 문제 1 : [개인정보 수집 유효기간](개인정보%20수집%20유효기간.js)

### 1. **문제 설명**

> 주어진 입력과 요구되는 출력에 대해 간략히 설명해주세요.

- **입력**

  ```ts
      today : String
      terms : String[]
      privacies : String[]
  ```

  - `today`는 `YYYY.MM.DD` 형태로 구성된 오늘 날짜를 의미하는 문자열입니다.
  - `terms`와 `privacies`는 idx로 연결되어 있습니다. (두 배열의 길이는 같습니다)
  - `terms`는 '[A-Z] [1-20]' 으로 구성된 문자열입니다
  - `privacies`는 '가입날짜 [A-Z]' 로 구성된 문자열입니다.
  - `privacies[i]`에 적힌 알파벳은 `terms[i]`에 적힌 알파벳의 숫자를 의미합니다. 해당 숫자는 약관 기간을 의미합니다. 약관 기관의 단위는 '달' 입니다.

- **출력** : 오늘 기준 약관 기간이 넘은 (파기해야 할) `privacies[i]` 의 인덱스 정보를 `i+1`해서 배열에 담아 출력합니다.

### 2. **사용한 데이터 구조와 알고리즘**

> 문제를 풀기 위해 사용한 주요한 데이터 구조 및 알고리즘에 대해 적어주세요.

- Hash, Array, 문자열 처리를 하는 방식으로 접근했습니다.

### 3. **의사 코드**

> 구현한 코드를 단계별로 설명해 주세요.

- **첫번째 푼 방식** : yyyy.mm.dd 형식을 유지하면서 풀기

  1. 현재 날짜 문자열을 [year, month, day] 형식의 Number 배열로 바꿉니다.
  2. 문자열로 주어진 terms 배열을 hash화 합니다.
  3. privacies를 순회하며 각 요소를 문자열 처리 후 현재 날짜와 비교합니다.
     이때 addDate함수를 통해 년도, 월, 일에 대한 가장자리 값에 대한 처리를 해 주었습니다.
  4. 만약 현재 날짜보다 만료되어야 하는 날짜가 작다면 answer 배열에 idx + 1 한값을 넣어줍니다.

- **두번째 푼 방식** : yyyy.mm.dd 형식을 날짜로 변환해서 풀기

  1. 현재 날짜 문자열을 year*12*28 + month\*28 + day 형식의 숫자로 변환합니다.
  2. 문자열로 주어진 terms 배열을 hash화 합니다.
  3. privacies를 순회하며 각 요소를 역시 year*12*28 + month\*28 + day 형식의 숫자로 변환합니다.
  4. 만약 현재 날짜보다 만료되어야 하는 날짜가 작다면 answer 배열에 idx + 1 한값을 넣어줍니다.

### 4. **시간 복잡도, 공간 복잡도 측정**

> 구현한 코드의 시간 복잡도와 공간 복잡도를 그 이유와 함께 적어주세요.

- O(N)
  두개의 방법 다 선형 시간 복잡도와 공간 복잡도를 가집니다.
  주로 reduce와 forEach가 입력값에 의해 계산이 변화되는 부분입니다. O(N+N) 이기에 시간 복잡도 상으로 O(N)의 시간 복잡도를 가지며 각 배열의 크기도 입력값에 의존하기에 O(N)의 공간 복잡도를 가집니다.

### 5. **최적화**

> 구현한 코드에서 최적화 할 수 있는 부분이 있을까요? 있다면 어떻게 수정되어야 할까요?

- 선형 시간 복잡도를 가지기에 시간 복잡도나 공간 복잡도 면에서는 괜찮다고 생각합니다. 두개의 풀이 중 두번째 풀이가 조건문에 의한 오류를 예방할 수 있어 더 나은 풀이라고 생각합니다.

### 6. **배운 점 또는 추가로 생각해볼 점**

> 인사이트에 대해 간략히 적어주세요.

- 두번째 풀이는 다른 사람들이 푼 것을 참고해서 푼 방식인데, 무조건 주어진 형식대로 푸는것이 아닌 주어지는 것 이상을 볼 수 있는 시각을 키워야 겠다는 다짐을 하게 되네요.

---

## 문제 2 : [이모티콘 할인행사](이모티콘%20할인행사.js)

### 1. **문제 설명**

> 주어진 입력과 요구되는 출력에 대해 간략히 설명해주세요.

- 입력

  ```ts
      users : Number[][]
      emoticons : Number[]
  ```

  - users 는 `[유저가 원하는 최소 할인율, 유저의 예산]` 으로 구성된 2차원 배열입니다.
  - emoticons는 구매 가능한 이모티콘의 가격의 배열입니다.
  - users의 길이는 100 미만이고 emoticons의 길이는 7 미만입니다.
  - 이모티콘에 적용되는 할인율은 10,20,30,40 중 하나입니다.

- 출력

  ```ts
      result : Number[]
  ```

  - 여러가지 경우의 수 중, '이모티콘 플러스를 최우선' 으로 하며 '이모티콘 판매액' 을 그 두번째의 우선순위로 두고 판매한 결과를 반환합니다. `[최대로 판매 가능한 이모티콘 플러스의 수, 이모티콘 판매액]` 형식입니다.

### 2. **사용한 데이터 구조와 알고리즘**

> 문제를 풀기 위해 사용한 주요한 데이터 구조 및 알고리즘에 대해 적어주세요.

- 주어진 입력값의 최대 크기가 작기 때문에, 깊이우선 완전탐색으로 접근했습니다.

### 3. **의사 코드**

> 구현한 코드를 단계별로 설명해 주세요.

❗할인율의 조건이 `[10,20,30,40]` 이기 때문에, 주어지는 `emoticons.length` 개로 이루어진 배열에서 4개의 할인율이 가질 수 있는 경우의 수를 모두 찾아야 합니다. (해당 경우의 수는 `4^emoticons.length` 입니다.)

1. 할인율의 조합을 구하는 DFS를 실행합니다. `dfs함수`는 순열을 담는 배열 `discountPermutation` 인자를 받습니다.
2. 함수 내부에서 `discount`를 이용해 반복문을 돌립니다. for문에서는 재귀 함수를 호출하며 기존 `discountPermutation` 배열을 깊이 복사하여 `discount[i]`을 마지막 인자로 추가한 배열을 다음 노드로 넘깁니다.
3. 재귀적으로 진행되다 `emoticons.length` 와 `discountPermutation.length` 가 같다면, 완성된 순열 중 하나라고 판단합니다.
4. 완성된 순열인 `discountPermutation`을 대상으로 기존 `emoticons`에 해당 할인율을 적용한 가격인 `applyDiscounts` 배열을 만듭니다.
5. `user`의 요소를 대상으로 반복문을 진행합니다. 반복을 진행하며 유저가 구매 기준으로 삼은 할인 비율과 적용된 할인율을 비교합니다.
6. 유저의 기준보다 같거나 많은 할인율이 적용되어 있으면 유저의 예산에서 할인이 적용된 가격을 뺍니다. 이때 유저의 예산이 0이하가 되면 이모티콘 플러스를 구매합니다. 아니라면 그대로 전체 판매엑에 유저가 구매한 금액을 더하고 해당 obj를 `answer`에 `push`합니다.
7. 재귀 함수가 끝난 후 각 할인율의 순열이 적용된 결과의 배열인 `answer`을 두가지 기준으로 정렬합니다.우선 이모티콘 플러스 판매 횟수를 내림차순으로 정렬하고, 차순위로 판매액 내림차순 기준으로 정렬합니다.
8. `answer`의 가장 첫번째에 위치한 요소를 배열에 담아 `return`합니다.

### 4. **풀이의 엣지 케이스**

> 해당 문제가 가질 수 있는 극단적인 케이스에 대해 적어주세요.

- 재귀적으로 구현된 코드이기에 계산해야 할 값이 극단적으로 많아지면 시간 초과가 뜰 것 같습니다. 하지만 해당 코드의 입력값이 제한적이였기에 해당 방법을 택했습니다.

### 4. **시간 복잡도, 공간 복잡도 측정**

> 구현한 코드의 시간 복잡도와 공간 복잡도를 그 이유와 함께 적어주세요.

- 이모티콘이 m개라면, 할인율의 경우의 수는 4^m가지가 됩니다. 그러나 m은 7이하이기에 4^7의 경우의 수를 가집니다. 따라서 할인율의 조합을 만드는 부분에서의 최악의 시간복잡도는 O(4^m) 입니다.
- 이후 탈출 조건문에서 진행되는 map 과 reduce는 emoticons와 users의 배열 크기에 의존하기에 각각 O(N) 의 시간복잡도를 가집니다.
- 따라서**O(4^m \* m \* n) 의 시간복잡도**를 가진다고 할 수 있습니다.

### 5. **배운 점 또는 추가로 생각해볼 점**

> 인사이트에 대해 간략히 적어주세요.

- 재귀로 순열을 구현했는데 재귀 호출 시, 얕은 복사가 아닌, 깊은 복사를 해서 넣어줘야 함을 알게 되었어요. 재귀는 계속 해도 해도 어렵네요,, 만날때마다 한번씩 공부해줘야겠어요.
- Javascript `sort` 함수가 `O(nlogn)` 의 시간복잡도를 가진다는 것을 알았어요.
  - 처음에 풀었던 풀이는 모든 계산 결과에 대해 `answer.push`를 한 후 조건 1과 조건 2를 기준으로 `sort`를 해주는 방식으로 구현했어요. 메모리 사용량이나 시간에서 유의미한 차이가 있을 줄 알았는데 크게 차이는 없어서 sort 함수에 대해 찾아보게 되었어요.

---

## 문제 3 : [택배 배달과 수거하기](./택배%20배달과%20수거하기.js)

- 해당 문제는 온전히 제 힘으로 풀진 못하고, youtube 송민기 님이 올려두신 [택배 배달과 수거하기 해설](https://youtu.be/iuMAd_Mg_ag?si=ZeNm3h3QwM2wcAfH) 을 참고해서 풀었어요.

### 1. **문제 설명**

> 주어진 입력과 요구되는 출력에 대해 간략히 설명해주세요.

- 입력

  ```ts
  cap : Number
  n : Number
  deliveries: Number[]
  pickups : Number[]
  ```

  - `cap` : 트럭의 최대 용량
  - `n` : === `deliveries.length` === `pickups.length`. 방문해야 하는 집의 개수
  - `deliveries` : 배달해야하는 집 표기 배열
  - `pickups` : 수거해야하는 집 표기 배열

- 출력 : 최소 이동 횟수

### 3. **사용한 데이터 구조와 알고리즘**

> 문제를 풀기 위해 사용한 주요한 데이터 구조 및 알고리즘에 대해 적어주세요.

- Greedy

### 4. **의사 코드**

> 구현한 코드를 단계별로 설명해 주세요.

- **가장 먼 곳의 작업을 먼저 끝내야한다.** 최소한으로 이동해야 하기 때문이다. 먼곳의 배달과 수거부터 해결해야 돌아오면서 추가 처리를 할 수 있습니다.
- **배달과 픽업은 별개의 것으로 봐도 무방**합니다. 한번 배달을 다녀올 때, 가장 멀리있는 배달 장소와 가장 멀리있는 픽업 장소 **둘 중 더 먼곳을 무조건 방문**해야 하기 때문입니다.

1. 배달을 해야하는 가장 먼 위치인 `i`, 픽업을 해야 하는 가장 먼 곳의 위치 `j`를 구합니다.
2. 둘중에 하나라도 해야 할 작업이 있는 경우 출발합니다. 따라서 이동해야 하는 거리는 `i`와 `j`중 더 큰 값에 +1을 한 후 x2를 한 것이 최초 이동 거리입니다.
3. 출발할때는 무조건 물건을 꽉 채워 간다 가정하고 이를 `curCap`에 할당합니다.
4. 배달해야 하는 값에 대한 처리를 진행합니다.

- 만약 `deliveries[i]`가 `curCap` 보다 크면

  - `curCap`을 0으로 만들고, `deliveries[i]` - `curCap`을 한다.
  - 이 경우, 더이상 전달할 수 있는 배달물이 없기에 물류창고로 돌아가야 합니다.

- 만약 `deliveries[i]`가 `curCap` 보다 작으면
  - `curCap`에서 `deliveries[i]`를 빼고, `deliveries[i]`를 0으로 만듭니다.
  - 배달 가능한 `curCap`이 존재하기에, 그 다음 배달 가능한 장소로 이동(`i--`) 해 `curCap`이 0보다 큰 동안 위 조건문을 반복 순회합니다.

5. 픽업 시 물류창고로 돌아오는 경우 무조건 현재 용량을 비운다 가정하고 픽업수 있는 최대 용량을 `curCap`으로 설정합니다.
6. 4번의 조건을 `pickups`로 바꾸어 적용합니다.
7. 해당 반복문 1회 순회 시 구해지는 `i`와 `j`의 크기가 해당 배달 진행 시 최대로 가야 하는 배달과 픽업 위치이다. 따라서 `i`와 `j`가 0이상인 경우 2번으로 돌아가 반복 처리를 진행합니다.

### 5. **시간 복잡도, 공간 복잡도 측정**

> 구현한 코드의 시간 복잡도와 공간 복잡도를 그 이유와 함께 적어주세요.

- 시간 복잡도 : O(N)
- 공간 복잡도 : O(1)

### 7. **배운 점 또는 추가로 생각해볼 점**

> 인사이트에 대해 간략히 적어주세요.

- Greedy문제를 좀 더 풀어봐야 할 것 같아요. 감이 잘 안잡히네요.
- 참고한 풀이들
  - [프로그레머스 전현서 님 해설](https://school.programmers.co.kr/questions/43364)
  - [유튜브 송민기 님의 택배 배달과 수거하기 해설](https://youtu.be/iuMAd_Mg_ag?si=ZeNm3h3QwM2wcAfH)
