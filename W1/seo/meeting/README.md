## 대면 스터디

- 날짜 : 11월 24일 오전 10시

## 문제 1 : [개인정보 수집 유효기간](개인정보%20수집%20유효기간.js)

### 1. **문제 설명**

> 주어진 입력과 요구되는 출력에 대해 간략히 설명해주세요.

- **입력**

  ```ts
      today : String
      terms : String[]
      privacies : String[]
  ```

  - `today`는 `YYYY.MM.DD` 형태로 구성된 오늘 날짜를 의미하는 문자열입니다.
  - `terms`와 `privacies`는 idx로 연결되어 있습니다. (두 배열의 길이는 같습니다)
  - `terms`는 '[A-Z] [1-20]' 으로 구성된 문자열입니다
  - `privacies`는 '가입날짜 [A-Z]' 로 구성된 문자열입니다.
  - `privacies[i]`에 적힌 알파벳은 `terms[i]`에 적힌 알파벳의 숫자를 의미합니다. 해당 숫자는 약관 기간을 의미합니다. 약관 기관의 단위는 '달' 입니다.

- **출력** : 오늘 기준 약관 기간이 넘은 (파기해야 할) `privacies[i]` 의 인덱스 정보를 `i+1`해서 배열에 담아 출력합니다.

### 2. **사용한 데이터 구조와 알고리즘**

> 문제를 풀기 위해 사용한 주요한 데이터 구조 및 알고리즘에 대해 적어주세요.

- Hash, Array, 문자열 처리를 하는 방식으로 접근했습니다.

### 3. **의사 코드**

> 구현한 코드를 단계별로 설명해 주세요.

- **첫번째 푼 방식** : yyyy.mm.dd 형식을 유지하면서 풀기

  1. 현재 날짜 문자열을 [year, month, day] 형식의 Number 배열로 바꿉니다.
  2. 문자열로 주어진 terms 배열을 hash화 합니다.
  3. privacies를 순회하며 각 요소를 문자열 처리 후 현재 날짜와 비교합니다.
     이때 addDate함수를 통해 년도, 월, 일에 대한 가장자리 값에 대한 처리를 해 주었습니다.
  4. 만약 현재 날짜보다 만료되어야 하는 날짜가 작다면 answer 배열에 idx + 1 한값을 넣어줍니다.

- **두번째 푼 방식** : yyyy.mm.dd 형식을 날짜로 변환해서 풀기

  1. 현재 날짜 문자열을 year*12*28 + month\*28 + day 형식의 숫자로 변환합니다.
  2. 문자열로 주어진 terms 배열을 hash화 합니다.
  3. privacies를 순회하며 각 요소를 역시 year*12*28 + month\*28 + day 형식의 숫자로 변환합니다.
  4. 만약 현재 날짜보다 만료되어야 하는 날짜가 작다면 answer 배열에 idx + 1 한값을 넣어줍니다.

### 4. **시간 복잡도, 공간 복잡도 측정**

> 구현한 코드의 시간 복잡도와 공간 복잡도를 그 이유와 함께 적어주세요.

- O(N)
  두개의 방법 다 상수 시간의 시간 복잡도와 공간 복잡도를 가집니다.
  주로 reduce와 forEach가 입력값에 의해 계산이 변화되는 부분입니다. O(N+N) 이기에 시간 복잡도 상으로 O(N)의 시간 복잡도를 가지며 각 배열의 크기도 입력값에 의존하기에 O(N)의 공간 복잡도를 가집니다.

### 5. **최적화**

> 구현한 코드에서 최적화 할 수 있는 부분이 있을까요? 있다면 어떻게 수정되어야 할까요?

- 상수 시간 복잡도를 가지기에 시간 복잡도나 공간 복잡도 면에서는 괜찮다고 생각합니다. 두개의 풀이 중 두번째 풀이가 조건문에 의한 오류를 예방할 수 있어 더 나은 풀이라고 생각합니다.

### 6. **배운 점 또는 추가로 생각해볼 점**

> 인사이트에 대해 간략히 적어주세요.

- 두번째 풀이는 다른 사람들이 푼 것을 참고해서 푼 방식인데, 무조건 주어진 형식대로 푸는것이 아닌 주어지는 것 이상을 볼 수 있는 시각을 키워야 겠다는 다짐을 하게 되네요.

## 문제 2 : [이모티콘 할인행사](이모티콘%20할인행사.js)

### 1. **문제 설명**

> 주어진 입력과 요구되는 출력에 대해 간략히 설명해주세요.

- 입력

  ```ts
      users : Number[][]
      emoticons : Number[]
  ```

  - users 는 `[유저가 원하는 최소 할인율, 유저의 예산]` 으로 구성된 2차원 배열입니다.
  - emoticons는 구매 가능한 이모티콘의 가격의 배열입니다.
  - users의 길이는 100 미만이고 emoticons의 길이는 7 미만입니다.
  - 이모티콘에 적용되는 할인율은 10,20,30,40 중 하나입니다.

- 출력

  ```ts
      result : Number[]
  ```

  - 여러가지 경우의 수 중, '이모티콘 플러스를 최우선' 으로 하며 '이모티콘 판매액' 을 그 두번째의 우선순위로 두고 판매한 결과를 반환합니다. `[최대로 판매 가능한 이모티콘 플러스의 수, 이모티콘 판매액]` 형식입니다.

### 2. **사용한 데이터 구조와 알고리즘**

> 문제를 풀기 위해 사용한 주요한 데이터 구조 및 알고리즘에 대해 적어주세요.

- 주어진 입력값의 최대 크기가 작기 때문에, 깊이우선 완전탐색으로 접근했습니다.
- 할인율의 조건이 [10,20,30,40] 이기 때문에, 주어지는 emoticons.length 개로 이루어진 배열에서 4개의 할인율이 가질 수 있는 경우의 수를 모두 찾아야 합니다. (해당 경우의 수는 4^emoticons.length 입니다.)

### 3. **의사 코드**

> 구현한 코드를 단계별로 설명해 주세요.

1. emoticons의 길이를 depth로 하여 재귀적으로 dfs를 를 진행합니다.
2. dfs함수는 순열을 담는 배열 discountPer 인자를 받습니다.
3. 함수 내부에서 discount의 종류인 4개번 for문을 돌립니다. for문에서는 재귀 함수를 호출하며 기존 discountPer 배열을 깊이 복사하여 discount[i]을 마지막 인자로 추가한 배열을 다음 노드로 넘깁니다.
4. 재귀적으로 진행되다 emoticons.length 와 discountPer.length 가 같다면, 완성된 순열 중 하나라고 판단합니다.
5. 완성된 순열인 discountPer을 대상으로 기존 emoticons에 해당 할인율을 적용한 가격인 applyDiscounts 배열을 만듭니다.
6. user의 요소를 대상으로 반복문을 진행합니다. 반복을 진행하며 유저가 구매 기준으로 삼은 할인 비율과 적용된 할인율을 비교합니다.
7. 유저의 기준보다 같거나 많은 할인율이 적용되어 있으면 유저의 예산에서 할인이 적용된 가격을 뺍니다. 이때 유저의 예산이 0이하가 되면 이모티콘 플러스를 구매합니다. 아니라면 그대로 전체 판매엑에 유저가 구매한 금액을 더하고 해당 obj를 answer에 push합니다.
8. 재귀 함수가 끝난 후 각 할인율의 순열이 적용된 결과의 배열인 answer을 두가지 기준으로 정렬합니다.우선 이모티콘 플러스 판매 횟수를 내림차순으로 정렬하고, 차순위로 판매액 내림차순 기준으로 정렬합니다.
9. answer의 가장 첫번째에 위치한 요소를 배열에 담아 return합니다.

### 4. **풀이의 엣지 케이스**

> 해당 문제가 가질 수 있는 극단적인 케이스에 대해 적어주세요.

- 재귀적으로 구현된 코드이기에 계산해야 할 값이 1만이 넘어가면 메모리 초과가 뜰 것 같습니다. 하지만 해당 코드의 입력값이 제한적이였기에 해당 방법을 택했습니다.

### 4. **시간 복잡도, 공간 복잡도 측정**

> 구현한 코드의 시간 복잡도와 공간 복잡도를 그 이유와 함께 적어주세요.

- 이모티콘이 m개라면, 할인율의 경우의 수는 4^m가지가 됩니다. 그러나 m은 7이하이기에 4^7의 경우의 수를 가집니다. 따라서 할인율의 조합을 만드는 부분에서의 최악의 시간복잡도는 O(4^m) 입니다.
- 이후 탈출 조건문에서 진행되는 map 과 reduce는 각각 emoticons와 users의 배열 크기에 의존하기에 O(N) 의 시간복잡도를 가집니다.
- 따라서**O(4^m \* m \* n) 의 시간복잡도**를 가진다고 할 수 있습니다.

### 5. **배운 점 또는 추가로 생각해볼 점**

> 인사이트에 대해 간략히 적어주세요.

- 재귀로 순열을 구현했는데 재귀 호출 시, 얕은 복사가 아닌, 깊은 복사를 해서 넣어줘야 함을 알게 되었어요. 재귀는 계속 해도 해도 어렵네요,, 만날때마다 한번씩 공부해줘야겠어요.
- Javascript sort 함수가 `O(nlogn)` 의 시간복잡도를 가진다는 것을 알았어요. 처음에 풀었던 풀이는 모든 계산 결과에 대해 answer.push를 한 후 조건 1과 조건 2를 기준으로 sort를 해주는 방식으로 구현했어요. 메모리 사용량이나 시간에서 유의미한 차이가 있을 줄 알았는데 크게 차이는 없어서 sort 함수에 대해 찾아보게 되었어요.
